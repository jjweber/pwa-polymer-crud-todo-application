/**
 * @license
 * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const astValue = require("../javascript/ast-value");
const ast_value_1 = require("../javascript/ast-value");
const esutil = require("../javascript/esutil");
const esutil_1 = require("../javascript/esutil");
const jsdoc = require("../javascript/jsdoc");
const analyze_properties_1 = require("./analyze-properties");
const polymer_element_1 = require("./polymer-element");
class Polymer2ElementScanner {
    scan(document, visit) {
        return __awaiter(this, void 0, void 0, function* () {
            let visitor = new ElementVisitor(document);
            yield visit(visitor);
            return visitor.getRegisteredElements();
        });
    }
}
exports.Polymer2ElementScanner = Polymer2ElementScanner;
class ElementVisitor {
    constructor(document) {
        this._possibleElements = new Map();
        this._registeredButNotFound = new Map();
        this._elements = [];
        this._document = document;
    }
    enterClassExpression(node, parent) {
        if (parent.type !== 'AssignmentExpression' &&
            parent.type !== 'VariableDeclarator') {
            return;
        }
        let className = astValue.getIdentifierName(parent.type === 'AssignmentExpression' ? parent.left : parent.id);
        if (className == null) {
            return;
        }
        const element = this._handleClass(node);
        if (element) {
            element.className = className;
            this._possibleElements.set(element.className, element);
        }
    }
    enterClassDeclaration(node) {
        const element = this._handleClass(node);
        if (element) {
            element.className = node.id.name;
            this._possibleElements.set(element.className, element);
        }
    }
    _handleClass(node) {
        const comment = esutil.getAttachedComment(node) || '';
        const docs = jsdoc.parseJsdoc(comment);
        const config = this._getConfig(node);
        const elementOptions = {
            description: (docs.description || '').trim(),
            events: esutil.getEventComments(node),
            sourceRange: this._document.sourceRangeForNode(node),
            properties: (config && this._getProperties(config)) || [],
        };
        // TODO(justinfagnani): figure out how or if to reconcile attributes
        // elementOptions.attributes = this._getObservedAttributes(node) ||
        //     (element.properties as ScannedPolymerProperty[])
        //         .filter((p) => p.notify == true)
        //         .map((p) => p.name);
        if (node.superClass) {
            elementOptions.superClass = ast_value_1.getIdentifierName(node.superClass);
        }
        const element = new polymer_element_1.ScannedPolymerElement(elementOptions);
        if (this._hasPolymerDocTag(docs)) {
            this._elements.push(element);
        }
        return element;
    }
    enterCallExpression(node) {
        const callee = astValue.getIdentifierName(node.callee);
        if (!(callee === 'window.customElements.define' ||
            callee === 'customElements.define')) {
            return;
        }
        const tagName = node.arguments[0] && astValue.expressionToValue(node.arguments[0]);
        if (tagName == null || (typeof tagName !== 'string')) {
            return;
        }
        const elementDefn = node.arguments[1];
        if (elementDefn == null) {
            return;
        }
        const element = this._getElement(tagName, elementDefn);
        if (!element) {
            return;
        }
        element.tagName = tagName;
        this._elements.push(element);
    }
    _getElement(tagName, elementDefn) {
        const className = astValue.getIdentifierName(elementDefn);
        if (className) {
            const element = this._possibleElements.get(className);
            if (element) {
                this._possibleElements.delete(className);
                return element;
            }
            else {
                this._registeredButNotFound.set(className, tagName);
                return null;
            }
        }
        if (elementDefn.type === 'ClassExpression') {
            return this._handleClass(elementDefn);
        }
        return null;
    }
    _hasPolymerDocTag(docs) {
        const tags = docs.tags || [];
        const elementTags = tags.filter((t) => t.tag === 'polymerElement');
        return elementTags.length >= 1;
    }
    _getConfig(node) {
        const possibleConfigs = node.body.body.filter((n) => n.type === 'MethodDefinition' && n.static === true &&
            n.kind === 'get' && ast_value_1.getIdentifierName(n.key) === 'config');
        const config = possibleConfigs.length === 1 && possibleConfigs[0];
        if (!config) {
            return null;
        }
        const configBody = config.value.body;
        if (configBody.body.length !== 1) {
            // not a single statement function
            return null;
        }
        if (configBody.body[0].type !== 'ReturnStatement') {
            return null;
        }
        const returnStatement = configBody.body[0];
        const returnValue = returnStatement.argument;
        if (!returnValue || returnValue.type !== 'ObjectExpression') {
            // TODO: warn
            return null;
        }
        return returnValue;
    }
    _getProperties(node) {
        const propertiesNode = esutil_1.getPropertyValue(node, 'properties');
        return propertiesNode ? analyze_properties_1.analyzeProperties(propertiesNode, this._document) :
            [];
    }
    // TODO(justinfagnani): move to vanilla element scanner
    // private _getObservedAttributes(node:
    // estree.ClassDeclaration|estree.ClassExpression) {
    //   const observedAttributesNode: estree.MethodDefinition =
    //       node.body.body.find((n) =>
    //         n.type === 'MethodDefinition' &&
    //         n.static === true &&
    //         astValue.getIdentifierName(n.key) === 'observedAttributes');
    //
    //   if (observedAttributesNode) {
    //     const body = observedAttributesNode.value.body.body[0];
    //     if (body && body.type === 'ReturnStatement' &&
    //         body.argument.type === 'ArrayExpression') {
    //       return this._extractAttributesFromObservedAttributes(body.argument);
    //     }
    //   }
    // }
    /**
     * Gets all found elements. Can only be called once.
     */
    getRegisteredElements() {
        const results = this._elements;
        for (const classAndTag of this._registeredButNotFound.entries()) {
            const className = classAndTag[0];
            const tagName = classAndTag[1];
            const element = this._possibleElements.get(className);
            if (element) {
                element.className = className;
                element.tagName = tagName;
                results.push(element);
            }
        }
        return results;
    }
}

//# sourceMappingURL=polymer2-element-scanner.js.map
