/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const analyzer_1 = require("../analyzer");
const css_parser_1 = require("../css/css-parser");
const html_element_reference_scanner_1 = require("../html/html-element-reference-scanner");
const html_import_scanner_1 = require("../html/html-import-scanner");
const html_parser_1 = require("../html/html-parser");
const html_script_scanner_1 = require("../html/html-script-scanner");
const html_style_scanner_1 = require("../html/html-style-scanner");
const javascript_parser_1 = require("../javascript/javascript-parser");
const json_parser_1 = require("../json/json-parser");
const model_1 = require("../model/model");
const telemetry_1 = require("../perf/telemetry");
const behavior_scanner_1 = require("../polymer/behavior-scanner");
const css_import_scanner_1 = require("../polymer/css-import-scanner");
const dom_module_scanner_1 = require("../polymer/dom-module-scanner");
const polymer_element_scanner_1 = require("../polymer/polymer-element-scanner");
const pseudo_element_scanner_1 = require("../polymer/pseudo-element-scanner");
const scan_1 = require("../scanning/scan");
const element_scanner_1 = require("../vanilla-custom-elements/element-scanner");
const warning_1 = require("../warning/warning");
const analysis_cache_1 = require("./analysis-cache");
/**
 * Represents an Analyzer with a given AnalysisCache instance.
 *
 * Used to provide a consistent cache in the face of updates happening in
 * parallel with analysis work. A given AnalyzerCacheContext is forked via
 * either the fileChanged or clearCaches methods.
 *
 * For almost all purposes this is an entirely internal implementation detail.
 */
class AnalyzerCacheContext {
    constructor(options) {
        this._parsers = new Map([
            ['html', new html_parser_1.HtmlParser()],
            ['js', new javascript_parser_1.JavaScriptParser({ sourceType: 'script' })],
            ['css', new css_parser_1.CssParser()],
            ['json', new json_parser_1.JsonParser()],
        ]);
        this._cache = new analysis_cache_1.AnalysisCache();
        this._telemetryTracker = new telemetry_1.TelemetryTracker();
        this._generation = 0;
        this._loader = options.urlLoader;
        this._resolver = options.urlResolver;
        this._parsers = options.parsers || this._parsers;
        this._lazyEdges = options.lazyEdges;
        this._scanners = options.scanners ||
            AnalyzerCacheContext._getDefaultScanners(this._lazyEdges);
    }
    static _getDefaultScanners(lazyEdges) {
        return new Map([
            [
                'html',
                [
                    new html_import_scanner_1.HtmlImportScanner(lazyEdges),
                    new html_script_scanner_1.HtmlScriptScanner(),
                    new html_style_scanner_1.HtmlStyleScanner(),
                    new dom_module_scanner_1.DomModuleScanner(),
                    new css_import_scanner_1.CssImportScanner(),
                    new html_element_reference_scanner_1.HtmlCustomElementReferenceScanner(),
                    new pseudo_element_scanner_1.PseudoElementScanner()
                ]
            ],
            [
                'js',
                [
                    new polymer_element_scanner_1.PolymerElementScanner(),
                    new behavior_scanner_1.BehaviorScanner(),
                    new element_scanner_1.ElementScanner()
                ]
            ],
        ]);
    }
    /**
     * Returns a copy of this cache context with proper cache invalidation.
     */
    filesChanged(urls) {
        const newCache = this._cache.invalidate(urls.map(url => this._resolveUrl(url)));
        return this._fork(newCache);
    }
    /**
     * Implements Analyzer#analyze, see its docs.
     */
    analyze(url, contents) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolvedUrl = this._resolveUrl(url);
            return this._cache.analyzedDocumentPromises.getOrCompute(resolvedUrl, () => __awaiter(this, void 0, void 0, function* () {
                const doneTiming = this._telemetryTracker.start('analyze: make document', url);
                const scannedDocument = yield this._scan(resolvedUrl, contents);
                if (scannedDocument === 'visited') {
                    throw new Error(`This should not happen. Got a cycle of length zero(!) scanning ${url}`);
                }
                const document = this._makeDocument(scannedDocument);
                doneTiming();
                return document;
            }));
        });
    }
    /**
     * Constructs a new analyzed Document and adds it to the analyzed Document
     * cache.
     */
    _makeDocument(scannedDocument) {
        const resolvedUrl = scannedDocument.url;
        if (this._cache.analyzedDocuments.has(resolvedUrl)) {
            throw new Error(`Internal error: document ${resolvedUrl} already exists`);
        }
        const document = new model_1.Document(scannedDocument, this);
        this._cache.analyzedDocuments.set(resolvedUrl, document);
        this._cache.analyzedDocumentPromises.getOrCompute(resolvedUrl, () => __awaiter(this, void 0, void 0, function* () { return document; }));
        document.resolve();
        return document;
    }
    /**
     * Gets an analyzed Document from the document cache. This is only useful for
     * Analyzer plugins. You almost certainly want to use `analyze()` instead.
     *
     * If a document has been analyzed, it returns the analyzed Document. If not
     * the scanned document cache is used and a new analyzed Document is returned.
     * If a file is in neither cache, it returns `undefined`.
     */
    _getDocument(url) {
        const resolvedUrl = this._resolveUrl(url);
        let document = this._cache.analyzedDocuments.get(resolvedUrl);
        if (document) {
            return document;
        }
        const scannedDocument = this._cache.scannedDocuments.get(resolvedUrl);
        return scannedDocument && this._makeDocument(scannedDocument);
    }
    /**
     * This is only useful for Analyzer plugins.
     *
     * If a url has been scanned, returns the ScannedDocument.
     */
    _getScannedDocument(url) {
        const resolvedUrl = this._resolveUrl(url);
        return this._cache.scannedDocuments.get(resolvedUrl);
    }
    getTelemetryMeasurements() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._telemetryTracker.getMeasurements();
        });
    }
    /**
     * Clear all cached information from this analyzer instance.
     *
     * Note: if at all possible, instead tell the analyzer about the specific
     * files that changed rather than clearing caches like this. Caching provides
     * large performance gains.
     */
    clearCaches() {
        return this._fork(new analysis_cache_1.AnalysisCache());
    }
    /**
     * Return a copy, but with the given cache.
     */
    _fork(cache) {
        const copy = new AnalyzerCacheContext({
            lazyEdges: this._lazyEdges,
            parsers: this._parsers,
            scanners: this._scanners,
            urlLoader: this._loader,
            urlResolver: this._resolver
        });
        copy._telemetryTracker = this._telemetryTracker;
        copy._cache = cache;
        copy._generation = this._generation + 1;
        return copy;
    }
    /**
     * Scan a toplevel document and all of its transitive dependencies.
     */
    _scan(resolvedUrl, contents, visited) {
        return __awaiter(this, void 0, void 0, function* () {
            if (visited && visited.has(resolvedUrl)) {
                return 'visited';
            }
            const actualVisited = visited || new Set();
            actualVisited.add(resolvedUrl);
            const scannedDocument = yield this._cache.scannedDocumentPromises.getOrCompute(resolvedUrl, () => __awaiter(this, void 0, void 0, function* () {
                const parsedDoc = yield this._parse(resolvedUrl, contents);
                return this._scanDocument(parsedDoc, actualVisited);
            }));
            /**
             * We cache the act of scanning dependencies separately from the act of
             * scanning a single file because while scanning is purely local to the
             * file, we need to rescan a file's transitive dependencies before
             * resolving if any of them have changed.
             */
            yield this._cache.dependenciesScanned.getOrCompute(scannedDocument.url, () => __awaiter(this, void 0, void 0, function* () {
                yield this._scanImports(scannedDocument, actualVisited);
            }));
            return scannedDocument;
        });
    }
    /**
     * Scans a ParsedDocument.
     */
    _scanDocument(document, visited, maybeAttachedComment) {
        return __awaiter(this, void 0, void 0, function* () {
            const warnings = [];
            const scannedFeatures = yield this._getScannedFeatures(document);
            // If there's an HTML comment that applies to this document then we assume
            // that it applies to the first feature.
            const firstScannedFeature = scannedFeatures[0];
            if (firstScannedFeature && firstScannedFeature instanceof model_1.ScannedElement) {
                firstScannedFeature.applyHtmlComment(maybeAttachedComment);
            }
            const scannedDocument = new model_1.ScannedDocument(document, scannedFeatures, warnings);
            if (!scannedDocument.isInline) {
                if (this._cache.scannedDocuments.has(scannedDocument.url)) {
                    throw new Error('Scanned document already in cache. This should never happen.');
                }
                this._cache.scannedDocuments.set(scannedDocument.url, scannedDocument);
            }
            yield this._scanInlineDocuments(scannedDocument, visited);
            return scannedDocument;
        });
    }
    _getScannedFeatures(document) {
        return __awaiter(this, void 0, void 0, function* () {
            const scanners = this._scanners.get(document.type);
            if (scanners) {
                return scan_1.scan(document, scanners);
            }
            return [];
        });
    }
    /**
     * Scans all of the transitive dependencies of the given document.
     *
     * Uses the `visited` set to break cycles.
     */
    _scanImports(scannedDocument, visited) {
        return __awaiter(this, void 0, void 0, function* () {
            if (scannedDocument.isInline) {
                throw new Error('Internal Error: _scanImports must only be called with a toplevel ' +
                    'document, never an inline document.');
            }
            const scannedImports = scannedDocument.getNestedFeatures().filter((e) => e instanceof model_1.ScannedImport);
            for (const scannedImport of scannedImports) {
                // TODO(garlicnation): Move this logic into model/document. During
                // the recursive feature walk, features from lazy imports
                // should be marked.
                if (scannedImport.type === 'lazy-html-import') {
                    continue;
                }
                const url = this._resolveUrl(scannedImport.url);
                try {
                    yield this._scan(url, undefined, visited);
                }
                catch (error) {
                    if (error instanceof analyzer_1.NoKnownParserError) {
                        // We probably don't want to fail when importing something
                        // that we don't know about here.
                        continue;
                    }
                    error = error || '';
                    // TODO(rictic): move this to the resolve phase, it will be improperly
                    //     cached as it is.
                    scannedDocument.warnings.push({
                        code: 'could-not-load',
                        message: `Unable to load import: ${error.message || error}`,
                        sourceRange: (scannedImport.urlSourceRange || scannedImport.sourceRange),
                        severity: warning_1.Severity.ERROR
                    });
                }
            }
            // Add the found dependencies to the dependency graph so that we can
            // do cache expiry when a file changes.
            this._cache.dependencyGraph.addDependenciesOf(scannedDocument.url, scannedImports.map(imp => this._resolveUrl(imp.url)));
        });
    }
    _scanInlineDocuments(containingDocument, visited) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const feature of containingDocument.features) {
                if (!(feature instanceof model_1.ScannedInlineDocument)) {
                    continue;
                }
                const locationOffset = {
                    line: feature.locationOffset.line,
                    col: feature.locationOffset.col,
                    filename: containingDocument.url
                };
                try {
                    const parsedDoc = this._parseContents(feature.type, feature.contents, containingDocument.url, { locationOffset, astNode: feature.astNode });
                    const scannedDoc = yield this._scanDocument(parsedDoc, visited, feature.attachedComment);
                    feature.scannedDocument = scannedDoc;
                }
                catch (err) {
                    if (err instanceof warning_1.WarningCarryingException) {
                        containingDocument.warnings.push(err.warning);
                        continue;
                    }
                    throw err;
                }
            }
        });
    }
    /**
     * Loads the content at the provided resolved URL.
     *
     * Currently does no caching. If the provided contents are given then they
     * are used instead of hitting the UrlLoader (e.g. when you have in-memory
     * contents that should override disk).
     */
    load(resolvedUrl, providedContents) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._loader.canLoad(resolvedUrl)) {
                throw new Error(`Can't load URL: ${resolvedUrl}`);
            }
            return providedContents == null ? yield this._loader.load(resolvedUrl) :
                providedContents;
        });
    }
    /**
     * Caching + loading wrapper around _parseContents.
     */
    _parse(resolvedUrl, providedContents) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._cache.parsedDocumentPromises.getOrCompute(resolvedUrl, () => __awaiter(this, void 0, void 0, function* () {
                const content = yield this.load(resolvedUrl, providedContents);
                const extension = path.extname(resolvedUrl).substring(1);
                const doneTiming = this._telemetryTracker.start('parse', 'resolvedUrl');
                const parsedDoc = this._parseContents(extension, content, resolvedUrl);
                doneTiming();
                return parsedDoc;
            }));
        });
    }
    /**
     * Parse the given string into the Abstract Syntax Tree (AST) corresponding
     * to its type.
     */
    _parseContents(type, contents, url, inlineInfo) {
        const parser = this._parsers.get(type);
        if (parser == null) {
            throw new analyzer_1.NoKnownParserError(`No parser for for file type ${type}`);
        }
        try {
            return parser.parse(contents, url, inlineInfo);
        }
        catch (error) {
            if (error instanceof warning_1.WarningCarryingException) {
                throw error;
            }
            throw new Error(`Error parsing ${url}:\n ${error.stack}`);
        }
    }
    /**
     * Resolves a URL with this Analyzer's `UrlResolver` if it has one, otherwise
     * returns the given URL.
     */
    _resolveUrl(url) {
        return this._resolver && this._resolver.canResolve(url) ?
            this._resolver.resolve(url) :
            url;
    }
}
exports.AnalyzerCacheContext = AnalyzerCacheContext;

//# sourceMappingURL=analyzer-cache-context.js.map
