import { Options } from '../analyzer';
import { Document, ScannedDocument } from '../model/model';
import { Measurement } from '../perf/telemetry';
/**
 * Represents an Analyzer with a given AnalysisCache instance.
 *
 * Used to provide a consistent cache in the face of updates happening in
 * parallel with analysis work. A given AnalyzerCacheContext is forked via
 * either the fileChanged or clearCaches methods.
 *
 * For almost all purposes this is an entirely internal implementation detail.
 */
export declare class AnalyzerCacheContext {
    private _parsers;
    /** A map from import url to urls that document lazily depends on. */
    private _lazyEdges;
    private _scanners;
    private _loader;
    private _resolver;
    private _cache;
    private _telemetryTracker;
    private _generation;
    private static _getDefaultScanners(lazyEdges);
    constructor(options: Options);
    /**
     * Returns a copy of this cache context with proper cache invalidation.
     */
    filesChanged(urls: string[]): AnalyzerCacheContext;
    /**
     * Implements Analyzer#analyze, see its docs.
     */
    analyze(url: string, contents?: string): Promise<Document>;
    /**
     * Constructs a new analyzed Document and adds it to the analyzed Document
     * cache.
     */
    private _makeDocument(scannedDocument);
    /**
     * Gets an analyzed Document from the document cache. This is only useful for
     * Analyzer plugins. You almost certainly want to use `analyze()` instead.
     *
     * If a document has been analyzed, it returns the analyzed Document. If not
     * the scanned document cache is used and a new analyzed Document is returned.
     * If a file is in neither cache, it returns `undefined`.
     */
    _getDocument(url: string): Document | undefined;
    /**
     * This is only useful for Analyzer plugins.
     *
     * If a url has been scanned, returns the ScannedDocument.
     */
    _getScannedDocument(url: string): ScannedDocument | undefined;
    getTelemetryMeasurements(): Promise<Measurement[]>;
    /**
     * Clear all cached information from this analyzer instance.
     *
     * Note: if at all possible, instead tell the analyzer about the specific
     * files that changed rather than clearing caches like this. Caching provides
     * large performance gains.
     */
    clearCaches(): AnalyzerCacheContext;
    /**
     * Return a copy, but with the given cache.
     */
    private _fork(cache);
    /**
     * Scan a toplevel document and all of its transitive dependencies.
     */
    private _scan(resolvedUrl, contents?, visited?);
    /**
     * Scans a ParsedDocument.
     */
    private _scanDocument(document, visited, maybeAttachedComment?);
    private _getScannedFeatures(document);
    /**
     * Scans all of the transitive dependencies of the given document.
     *
     * Uses the `visited` set to break cycles.
     */
    private _scanImports(scannedDocument, visited);
    private _scanInlineDocuments(containingDocument, visited);
    /**
     * Loads the content at the provided resolved URL.
     *
     * Currently does no caching. If the provided contents are given then they
     * are used instead of hitting the UrlLoader (e.g. when you have in-memory
     * contents that should override disk).
     */
    load(resolvedUrl: string, providedContents?: string): Promise<string>;
    /**
     * Caching + loading wrapper around _parseContents.
     */
    private _parse(resolvedUrl, providedContents?);
    /**
     * Parse the given string into the Abstract Syntax Tree (AST) corresponding
     * to its type.
     */
    private _parseContents(type, contents, url, inlineInfo?);
    /**
     * Resolves a URL with this Analyzer's `UrlResolver` if it has one, otherwise
     * returns the given URL.
     */
    private _resolveUrl(url);
}
