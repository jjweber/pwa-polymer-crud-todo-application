/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
const resolvable_1 = require("./resolvable");
/**
 * The metadata for all features and elements defined in one document
 */
class ScannedDocument {
    constructor(document, features, warnings) {
        this.isInline = false;
        this.sourceRange = undefined; // TODO(rictic): track this
        this.document = document;
        this.features = features;
        this.warnings = warnings || [];
        this.isInline = document.isInline;
    }
    get url() {
        return this.document.url;
    }
    /**
     * Gets all features in this scanned document and all inline documents it
     * contains.
     */
    getNestedFeatures() {
        const result = [];
        this._getNestedFeatures(result);
        return result;
    }
    _getNestedFeatures(features) {
        for (const feature of this.features) {
            // Ad hoc test needed here to avoid a problematic import loop.
            if (feature.constructor.name === 'ScannedDocument' &&
                feature['scannedDocument']) {
                const innerDoc = feature['scannedDocument'];
                innerDoc._getNestedFeatures(features);
            }
            else {
                features.push(feature);
            }
        }
    }
}
exports.ScannedDocument = ScannedDocument;
class Document {
    constructor(base, analyzer) {
        this.kinds = new Set(['document']);
        this.identifiers = new Set();
        this._localFeatures = new Set();
        /** See parsedDocument. */
        this.astNode = null;
        /**
         * To handle recursive dependency graphs we must track whether we've started
         * resolving this Document so that we can reliably early exit even if one
         * of our dependencies tries to resolve this document.
         */
        this._begunResolving = false;
        /**
         * True after this document and all of its children are finished resolving.
         */
        this._doneResolving = false;
        this._featuresByKind = null;
        this._featuresByKindAndId = null;
        if (base == null) {
            throw new Error('base is null');
        }
        if (analyzer == null) {
            throw new Error('analyzer is null');
        }
        this._scannedDocument = base;
        this.analyzer = analyzer;
        if (!base.isInline) {
            this.identifiers.add(this.url);
        }
        this.kinds.add(`${this.parsedDocument.type}-document`);
        this.warnings = Array.from(base.warnings);
    }
    get url() {
        return this._scannedDocument.url;
    }
    get isInline() {
        return this._scannedDocument.isInline;
    }
    get parsedDocument() {
        return this._scannedDocument.document;
    }
    get sourceRange() {
        return this._scannedDocument.sourceRange;
    }
    get resolved() {
        return this._doneResolving;
    }
    get type() {
        return this.parsedDocument.type;
    }
    /**
     * Resolves all features of this document, so that they have references to all
     * their dependencies.
     *
     * This method can only be called once
     */
    // TODO(justinfagnani): move to ScannedDocument
    resolve() {
        if (this._doneResolving) {
            throw new Error('resolve can only be called once');
        }
        if (this._begunResolving) {
            return;
        }
        this._begunResolving = true;
        this._addFeature(this);
        for (const scannedFeature of this._scannedDocument.features) {
            if (resolvable_1.isResolvable(scannedFeature)) {
                const feature = scannedFeature.resolve(this);
                if (feature) {
                    this._addFeature(feature);
                }
            }
        }
        this._doneResolving = true;
    }
    /**
     * Adds and indexes a feature to this documentled before resolve().
     */
    _addFeature(feature) {
        if (this._doneResolving) {
            throw new Error('_addFeature can not be called after _resolve()');
        }
        this._indexFeature(feature);
        this._localFeatures.add(feature);
    }
    getByKind(kind) {
        if (this._featuresByKind) {
            // We have a fast index! Use that.
            return this._featuresByKind.get(kind) || new Set();
        }
        else if (this._doneResolving) {
            // We're done discovering features in this document and its children so
            // we can safely build up the indexes.
            this._buildIndexes();
            return this.getByKind(kind);
        }
        return this._getByKind(kind, new Set());
    }
    getById(kind, identifier) {
        if (this._featuresByKindAndId) {
            // We have a fast index! Use that.
            const idMap = this._featuresByKindAndId.get(kind);
            return (idMap && idMap.get(identifier)) || new Set();
        }
        else if (this._doneResolving) {
            // We're done discovering features in this document and its children so
            // we can safely build up the indexes.
            this._buildIndexes();
            return this.getById(kind, identifier);
        }
        const result = new Set();
        for (const featureOfKind of this.getByKind(kind)) {
            if (featureOfKind.identifiers.has(identifier)) {
                result.add(featureOfKind);
            }
        }
        return result;
    }
    getOnlyAtId(kind, identifier) {
        const results = this.getById(kind, identifier);
        if (results.size > 1) {
            throw new Error(`Expected to find at most one ${kind} with id ${identifier} ` +
                `but found ${results.size}.`);
        }
        return results.values().next().value || undefined;
    }
    _getByKind(kind, documentsWalked) {
        const result = new Set();
        documentsWalked.add(this);
        for (const feature of this._localFeatures) {
            if (feature.kinds.has(kind)) {
                result.add(feature);
            }
            if (feature.kinds.has('import')) {
                const document = feature.document;
                if (!documentsWalked.has(document)) {
                    for (const subFeature of document._getByKind(kind, documentsWalked)) {
                        result.add(subFeature);
                    }
                }
            }
            if (feature.kinds.has('document')) {
                const document = feature;
                if (!documentsWalked.has(document)) {
                    for (const subFeature of document._getByKind(kind, documentsWalked)) {
                        result.add(subFeature);
                    }
                }
            }
        }
        return result;
    }
    /**
     * Get features for all documents reachable via imports in this document.
     * If `deep` is false, only return features in this document.
     */
    getFeatures(deep) {
        if (deep == null) {
            deep = true;
        }
        const result = new Set();
        this._getFeatures(result, new Set(), deep);
        return result;
    }
    _getFeatures(result, visited, deep) {
        if (visited.has(this)) {
            return;
        }
        visited.add(this);
        for (const feature of this._localFeatures) {
            result.add(feature);
            if (deep) {
                if (feature.kinds.has('document')) {
                    feature._getFeatures(result, visited, deep);
                }
                if (feature.kinds.has('import')) {
                    feature.document._getFeatures(result, visited, deep);
                }
            }
        }
    }
    /**
     * Get warnings for this document and all local features of this document. If
     * `deep` is true, return warnings for all documents and features reachable
     * via imports in this document.
     */
    getWarnings(deep) {
        const warnings = new Set(this.warnings);
        if (deep == null) {
            deep = false;
        }
        for (const feature of this.getFeatures(deep)) {
            for (const warning of feature.warnings) {
                warnings.add(warning);
            }
        }
        return Array.from(warnings);
    }
    toString() {
        return this._toString(new Set()).join('\n');
    }
    _toString(documentsWalked) {
        let result = [`<Document type=${this.parsedDocument.type} url=${this.url}>\n`];
        if (documentsWalked.has(this)) {
            return result;
        }
        documentsWalked.add(this);
        for (const localFeature of this._localFeatures) {
            if (localFeature instanceof Document) {
                result = result.concat(localFeature._toString(documentsWalked).map(line => `  ${line}`));
            }
            else {
                let subResult = localFeature.toString();
                if (subResult === '[object Object]') {
                    subResult =
                        `<${localFeature.constructor.name} kinds="${Array
                            .from(localFeature.kinds)
                            .join(', ')}" ids="${Array.from(localFeature.identifiers)
                            .join(',')}">}`;
                }
                result.push(`  ${subResult}`);
            }
        }
        return result;
    }
    stringify() {
        const inlineDocuments = Array.from(this._localFeatures)
            .filter(f => f instanceof Document && f.isInline)
            .map(d => d.parsedDocument);
        return this.parsedDocument.stringify({ inlineDocuments: inlineDocuments });
    }
    _initIndexes() {
        this._featuresByKind = new Map();
        this._featuresByKindAndId = new Map();
    }
    _indexFeature(feature) {
        if (!this._featuresByKind || !this._featuresByKindAndId) {
            return;
        }
        for (const kind of feature.kinds) {
            const kindSet = this._featuresByKind.get(kind) || new Set();
            kindSet.add(feature);
            this._featuresByKind.set(kind, kindSet);
            for (const id of feature.identifiers) {
                const identifiersMap = this._featuresByKindAndId.get(kind) ||
                    new Map();
                this._featuresByKindAndId.set(kind, identifiersMap);
                const idSet = identifiersMap.get(id) || new Set();
                identifiersMap.set(id, idSet);
                idSet.add(feature);
            }
        }
    }
    _buildIndexes() {
        if (this._featuresByKind) {
            throw new Error('Tried to build indexes multiple times. This should never happen.');
        }
        if (!this._doneResolving) {
            throw new Error(`Tried to build indexes before finished resolving. ` +
                `Need to wait until afterwards or the indexes would be incomplete.`);
        }
        this._initIndexes();
        for (const feature of this.getFeatures()) {
            this._indexFeature(feature);
        }
    }
}
exports.Document = Document;

//# sourceMappingURL=document.js.map
