/**
 * @license
 * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
"use strict";
const fs = require("fs");
const jsonschema = require("jsonschema");
const pathLib = require("path");
function generateElementMetadata(elements, packagePath) {
    return {
        schema_version: '1.0.0',
        elements: elements.map(e => serializeElement(e, packagePath))
            .filter(e => !!e)
    };
}
exports.generateElementMetadata = generateElementMetadata;
const validator = new jsonschema.Validator();
const schema = JSON.parse(fs.readFileSync(pathLib.join(__dirname, 'analysis.schema.json'), 'utf-8'));
class ValidationError extends Error {
    constructor(result) {
        const message = `Unable to validate serialized Polymer analysis. ` +
            `Got ${result.errors.length} errors: ` +
            `${result.errors.map(err => '    ' + (err.message || err)).join('\n')}`;
        super(message);
        this.errors = result.errors;
    }
}
exports.ValidationError = ValidationError;
/**
 * Throws if the given object isn't a valid AnalyzedPackage according to
 * the JSON schema.
 */
function validateElements(analyzedPackage) {
    const result = validator.validate(analyzedPackage, schema);
    if (result.throwError) {
        throw result.throwError;
    }
    if (result.errors.length > 0) {
        throw new ValidationError(result);
    }
    if (!/^1\.\d+\.\d+$/.test(analyzedPackage.schema_version)) {
        throw new Error(`Invalid schema_version in AnalyzedPackage. ` +
            `Expected 1.x.x, got ${analyzedPackage.schema_version}`);
    }
}
exports.validateElements = validateElements;
function serializeElement(resolvedElement, packagePath) {
    if (!resolvedElement.tagName) {
        return null;
    }
    const path = resolvedElement.sourceRange.file;
    const packageRelativePath = pathLib.relative(packagePath, resolvedElement.sourceRange.file);
    const attributes = resolvedElement.attributes.map(a => serializeAttribute(resolvedElement, path, a));
    const properties = resolvedElement.properties
        .filter(p => !p.private &&
        // Blacklist functions until we figure out what to do.
        p.type !== 'Function')
        .map(p => serializeProperty(resolvedElement, path, p));
    const events = resolvedElement.events.map(e => ({
        name: e.name,
        description: e.description || '',
        type: 'CustomEvent',
        metadata: resolvedElement.emitEventMetadata(e)
    }));
    return {
        tagname: resolvedElement.tagName,
        description: resolvedElement.description || '',
        superclass: 'HTMLElement',
        path: packageRelativePath,
        attributes: attributes,
        properties: properties,
        styling: {
            cssVariables: [],
            selectors: [],
        },
        demos: (resolvedElement.demos || []).map(d => d.path),
        slots: resolvedElement.slots.map(s => {
            return { description: '', name: s.name, range: s.range };
        }),
        events: events,
        metadata: resolvedElement.emitMetadata(),
        sourceRange: resolveSourceRangePath(path, resolvedElement.sourceRange),
    };
}
function serializeProperty(resolvedElement, elementPath, resolvedProperty) {
    const property = {
        name: resolvedProperty.name,
        type: resolvedProperty.type || '?',
        description: resolvedProperty.description || '',
        sourceRange: resolveSourceRangePath(elementPath, resolvedProperty.sourceRange)
    };
    if (resolvedProperty.default) {
        property.defaultValue = resolvedProperty.default;
    }
    property.metadata = resolvedElement.emitPropertyMetadata(resolvedProperty);
    return property;
}
function serializeAttribute(resolvedElement, elementPath, resolvedAttribute) {
    const attribute = {
        name: resolvedAttribute.name,
        description: resolvedAttribute.description || '',
        sourceRange: resolveSourceRangePath(elementPath, resolvedAttribute.sourceRange)
    };
    if (resolvedAttribute.type) {
        attribute.type = resolvedAttribute.type;
    }
    attribute.metadata = resolvedElement.emitAttributeMetadata(resolvedAttribute);
    return attribute;
}
function resolveSourceRangePath(elementPath, sourceRange) {
    if (!sourceRange) {
        return;
    }
    if (!sourceRange.file) {
        return sourceRange;
    }
    if (elementPath === sourceRange.file) {
        return { start: sourceRange.start, end: sourceRange.end };
    }
    // The source location's path is relative to file resolver's base, so first
    // we need to make it relative to the element.
    const filePath = pathLib.relative(pathLib.dirname(elementPath), sourceRange.file);
    return { file: filePath, start: sourceRange.start, end: sourceRange.end };
}

//# sourceMappingURL=generate-elements.js.map
